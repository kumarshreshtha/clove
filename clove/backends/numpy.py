import numpy as _np
from clove import binding_utils as _binding_utils
from clove.backends import numpy_bk as _npbk
from clove import ops as _ops

# creation routines
empty = _binding_utils.wrap_creation_op(_np.empty, _npbk.Numpy)
empty_like = _binding_utils.wrap_creation_op(_np.empty_like, _npbk.Numpy)
eye = _binding_utils.wrap_creation_op(_np.eye, _npbk.Numpy)
identity = _binding_utils.wrap_creation_op(_np.identity, _npbk.Numpy)
ones = _binding_utils.wrap_creation_op(_np.ones, _npbk.Numpy)
ones_like = _binding_utils.wrap_creation_op(_np.ones_like, _npbk.Numpy)
zeros = _binding_utils.wrap_creation_op(_np.zeros, _npbk.Numpy)
zeros_like = _binding_utils.wrap_creation_op(_np.zeros_like, _npbk.Numpy)
full = _binding_utils.wrap_creation_op(_np.full, _npbk.Numpy)
full_like = _binding_utils.wrap_creation_op(_np.full_like, _npbk.Numpy)
array = _binding_utils.wrap_creation_op(_np.array, _npbk.Numpy)
asarray = _binding_utils.wrap_creation_op(_np.asarray, _npbk.Numpy)
asanyarray = _binding_utils.wrap_creation_op(_np.asanyarray, _npbk.Numpy)
ascontiguousarray = _binding_utils.wrap_creation_op(_np.ascontiguousarray,
                                                    _npbk.Numpy)
frombuffer = _binding_utils.wrap_creation_op(_np.frombuffer, _npbk.Numpy)
fromfile = _binding_utils.wrap_creation_op(_np.fromfile, _npbk.Numpy)
fromfunction = _binding_utils.wrap_creation_op(_np.fromfunction, _npbk.Numpy)
fromiter = _binding_utils.wrap_creation_op(_np.fromiter, _npbk.Numpy)
arange = _binding_utils.wrap_creation_op(_np.arange, _npbk.Numpy)
linspace = _binding_utils.wrap_creation_op(_np.linspace, _npbk.Numpy)
logspace = _binding_utils.wrap_creation_op(_np.logspace, _npbk.Numpy)
geomspace = _binding_utils.wrap_creation_op(_np.geomspace, _npbk.Numpy)
meshgrid = _binding_utils.wrap_creation_op(_np.meshgrid, _npbk.Numpy)
diag = _binding_utils.wrap_creation_op(_np.diag, _npbk.Numpy)
diagflat = _binding_utils.wrap_creation_op(_np.diagflat, _npbk.Numpy)
tri = _binding_utils.wrap_creation_op(_np.tri, _npbk.Numpy)
tril = _binding_utils.wrap_creation_op(_np.tril, _npbk.Numpy)
triu = _binding_utils.wrap_creation_op(_np.triu, _npbk.Numpy)
vander = _binding_utils.wrap_creation_op(_np.vander, _npbk.Numpy)

# operators
clone = _binding_utils.make_bound_backend_fn(_ops.CloneOp, _npbk.Numpy)
transpose = _binding_utils.make_bound_backend_fn(_ops.TransposeOp, _npbk.Numpy)
permute = _binding_utils.make_bound_backend_fn(_ops.PermuteOp, _npbk.Numpy)
add = _binding_utils.make_bound_backend_fn(_ops.AddOp, _npbk.Numpy)
multiply = _binding_utils.make_bound_backend_fn(_ops.MulOp, _npbk.Numpy)
matmul = _binding_utils.make_bound_backend_fn(_ops.MatmulOp, _npbk.Numpy)
negative = _binding_utils.make_bound_backend_fn(_ops.NegOp, _npbk.Numpy)
subtract = _binding_utils.make_bound_backend_fn(_ops.MinusOp, _npbk.Numpy)
sum = _binding_utils.make_bound_backend_fn(_ops.SumOp, _npbk.Numpy)
exp = _binding_utils.make_bound_backend_fn(_ops.ExpOp, _npbk.Numpy)
log = _binding_utils.make_bound_backend_fn(_ops.LogOp, _npbk.Numpy)
power = _binding_utils.make_bound_backend_fn(_ops.PowOp, _npbk.Numpy)
sigmoid = _binding_utils.make_bound_backend_fn(_ops.SigmoidOp, _npbk.Numpy)
tanh = _binding_utils.make_bound_backend_fn(_ops.TanhOp, _npbk.Numpy)
expand = _binding_utils.make_bound_backend_fn(_ops.ExpandOp, _npbk.Numpy)
